The location of the user is detected when the user scans an \ac{nfc} tag, the \ac{nfc} tag are placed around the exhibition and at booths, to provide the user with easy location determination. When the user location is known, it is possible for them to navigate to a specific booth.

\section{MapView vs MapFragment}
Our initial thought on how to implement the floor plan on the phone was to use the service provided by Google Maps. We knew that it could be implemented on the phone because we had previously seen it being used in other applications. What we did not know, was if we could override the standard Google Maps tiles with our own custom tile set of the floor plan. A tile is a single picture containing a piece of the map. Depending on the zoom level each tile contain a smaller piece of the actual map.
\begin{figure}[H]
\centering
\includegraphics[width=0.8\textwidth]{img/tilessidebyside.png}
\caption{Google Maps tile and one of our custom tiles \citep{googlemaptile}}
\label{fig:maptiles}
\end{figure}
We need to implement our own custom tile set because we want to show the floor plan of a building, instead of a map of the Earth. We read the documentation provided by Google Maps\citep{googlemapsapi}, and we found that Android allows implementation of maps in an application using Android MapFragment, however it is not possible to override the standard tiles with your own tiles so this was not useful for us\citep{googlemapfragment}. We then thought of implementing the floor plan with a WebView which is basically a browser inside the application, and use JavaScript to create the map. With JavaScript it is possible to override the standard tile set with your own, but the performance on the phone was horrible so we scratched the idea. After some research we found a solution to our problem. We use a MapFragment and instead of overriding the standard tile set we simply overlay, and only show our custom tile set of the floor plan.

\section{Mercator projection}\label{sec:mercatorprojection}
We wanted to use the Google Maps \ac{api}, and maps shown with this is default done with the Mercator projection. Mercator projection is a way of displaying a sphere on a two dimensional map. There are a lot of ways of projecting a sphere on a map, but one of the most successful ones is the Mercator projection. The Mercator projection is often chosen because of its navigational properties. One of the biggest navigational properties Mercator provides, is its ability to represent lines of constant course as straight lines.

A Mercator projected map is illustrated by \autoref{fig:mercatorexplain}. Let the globe be a spherical balloon, the balloon is inflated inside a cylinder, and sticks to the cylinders side as it is inflated. The three first pictures on \autoref{fig:mercatorexplain} shows the balloon being inflated, the last picture shows the cylinder being cut open and displayed as a two dimensional map.
\begin{figure}[H]
\centering
\includegraphics[width=0.8\textwidth]{img/mercatorexplain.png}
\caption{Explanation of Mercator projection \citep{mercatorexplain}}
\label{fig:mercatorexplain}
\end{figure}
The \autoref{fig:mercatorexplain} also shows how the top part(latitude) of the spherical balloon is stretched, for it to fit inside the cylinder. This is one of the disadvantages of the Mercator projection, the landmasses and continents are not scaled correctly.
\begin{figure}[H]
\centering
\includegraphics[width=0.7\textwidth]{img/mercatorworld.pdf}
\caption{The World - Mercator projection  \citep{mercatorworld}}
\label{fig:mercatorworld}
\end{figure} As seen on the \autoref{fig:mercatorworld} Greenland is almost the same size as Africa, but in reality Africa is 14 times bigger than Greenland.

\section{Google Maps}
Normally a map is distorted by the Mercator projection, but in our case this is not a problem, since our floor plan already is a plane. The Google Maps \ac{api} is both available in JavaScript and Java(Android), although the Java \ac{api} has a few limitations.

The Google Maps \ac{api} allows the user to zoom on the floor plan, the floor plan we use as an example is shown in \appref{appendixStart}. Zooming on the floor plan allows us to present the floor plan in more detail. For this to work we need to split our original floor plan picture into small tiles, the tiles are always the size $256 \times 256$ pixels. As the zoom level increases the more tiles are needed to present the floor plan, so at zoom level 2 the floor plan will be rendered as a $4 \times 4$ grid. At zoom level 3 an $8 \times 8$ grid, and so on. \autoref{fig:tilecoordinates} shows how the original picture is split into tiles at zoom level 3. Each zoom level has to be stored on either a server or locally.

\begin{figure}[H]
\centering
\includegraphics[width=0.7\textwidth]{img/tilecoordinates2.png}
\caption{Tile split example with zoom level 3 \citep{tilecoordinates}}
\label{fig:tilecoordinates}
\end{figure}

The Google Maps \ac{api} also allows us to draw different shapes and elements onto the floor plan. The following describes the shapes and elements we create and use.%In this section we show and explain how these elements are created and used.

\subsubsection*{Markers}
Markers are used to identify locations on the floor plan. The marker's icon is customisable so it can be used to differentiate between the types of locations. Markers are also equipped with an info window, which pop up if the marker is pressed. The info window is used to give a short description about the location. We use the markers to display information about the booths and also the position of the user on the floor plan. An example of a marker is the small info markers, as seen on \autoref{fig:markerandboothexample}. \autoref{lst:drawmarker} shows how to draw a marker on the floor plan.
\begin{figure}[H]
\centering
\includegraphics[width=0.7\textwidth]{img/markerandbooth.png}
\caption{Marker and booth example}
\label{fig:markerandboothexample}
\end{figure}
\begin{lstlisting}[language=java, label=lst:drawmarker, caption=Method for drawing a marker.]
public Marker drawMarker(LatLng latLng, String title, String snippet, int picture){
    MarkerOptions markerOptions = new MarkerOptions()
            .position(latLng)
            .title(title)
            .snippet(snippet)
            .icon(BitmapDescriptorFactory.fromResource(picture));
    Marker marker = this.googleMap.addMarker(markerOptions);
    this.markerList.add(marker);
    return marker;
}
\end{lstlisting}
\begin{description}
\item[Line 1] Draw marker method, parameters are: a single latitude and longitude point, a title for the marker, and a snippet(description), and a icon picture. 
\item[Lines 2-6] Create the \lstinline|markerOptions| object, with the parameters.
\item[Line 7-9] Draw the marker on the floor plan with the Google Maps \ac{api}, the draw method returns the marker object. The \lstinline|marker| is stored in a list, if it should be removed or edited later. Return the \lstinline|marker| to the method caller.
\end{description}

\subsubsection*{Polylines}
Polylines presents a set a of connected line segments on the floor plan. The polyline object consists of a set of latitude and longitude coordinates, and creates a connected line between all the coordinates in an ordered sequence. The polyline's colour can also be customised to differentiate between other polylines. We use the polyline to show the walk path on the floor plan, and also to show the route to different booths from the user's location. \autoref{fig:polylineexample} shows an example of a polyline, the array that defines the polyline on \autoref{fig:polylineexample} would look like this \lstinline|{NodeA, NodeB, NodeC, NodeB, NodeD}|. \autoref{lst:drawpolyline} shows how to draw a polyline on the floor plan.
\begin{figure}[H]
\centering
\includegraphics[width=0.9\textwidth]{img/polylineExample.png}
\caption{Polyline example}
\label{fig:polylineexample}
\end{figure}
\begin{lstlisting}[language=java, label=lst:drawpolyline, caption=Method for drawing a polyline.]
public Polyline drawPolyline(ArrayList<Node> nodes, float strokeWidth, int color, int zIndex){
    ArrayList<LatLng> polyPoints = new ArrayList<LatLng>();
    for(Node n : nodes){
        polyPoints.add(n.getPosition());
    }
    PolylineOptions polylineOptions = new PolylineOptions()
            .addAll(polyPoints)
            .width(strokeWidth)
            .color(color)
            .zIndex(zIndex);
    Polyline polyline = this.googleMap.addPolyline(polylineOptions);
    return polyline
}
\end{lstlisting}
\begin{description}
\item[Line 1] The draw marker method, parameters are: an array with nodes, stroke width, a color, and a z-index. The z-index defines the order of the drawn objects,  objects with a higher z-index will be drawn on top of objects with a lower z-index. 
\item[Lines 2-5] Extract the node's latitude and longitude, and add them to the newly created \lstinline|polyPoints|.
\item[Lines 6-10] Create the \lstinline|polylineOptions| object, with the function parameters, and the \lstinline|polyPoints|.
\item[Line 11] Draw the polyline on the floor plan with the Google Maps \ac{api}, the draw method returns the polyline object. Return the \lstinline|polyline| to the method caller.
\end{description}

\subsubsection*{Polygons}
Polygons are similar to polylines in that they consist of a series of latitude and longitude coordinates. But instead it being a line segment that is open, the polygons are designed to be a closed region. The polygon's interior is also filled with a colour, which makes it perfect for showing booths on our floor plan. On \autoref{fig:markerandboothexample} the green shape shows a polygon which represents a booth. \autoref{lst:drawpolygon} shows how to draw a polygon on the floor plan.
\begin{lstlisting}[language=java, label=lst:drawpolygon, caption=Method for drawing a polygon.]
public Polygon drawPolygon(List<LatLng> latLngs, float strokeWidth, int strokeColor, int fillColor, int zIndex){
    PolygonOptions polygonOptions = new PolygonOptions()
            .addAll(latLngs)
            .strokeWidth(strokeWidth)
            .strokeColor(strokeColor)
            .fillColor(fillColor)
            .zIndex(zIndex);
    Polygon polygon =  this.googleMap.addPolygon(polygonOptions);
    polygonList.add(polygon);
    return polygon;
}
\end{lstlisting}
\begin{description}
\item[Line 1] Draw polygon method, parameters are: an array of four latitude and longitude points, a stroke width, a stroke colour, a interior colour, and the z-index of the object. 
\item[Lines 2-7] Create the \lstinline|polygonOptions| object, with the parameters.
\item[Line 8-10] Draw the polygon on the floor plan with the Google Maps \ac{api}, the draw method returns the polygon object. The \lstinline|polygon| is stored in a list, if it should be removed or edited later. Return the \lstinline|polygon| to the method caller.
\end{description}

\section{Implementation of Floor Plan}
In this section we will explain how we implemented our map of the floor plan using Google Maps. Implementing the default map on an Android phone is actually simple. All that is needed is to implement a fragment called \lstinline|MapFragment| in an activity.

\subsection*{Tile Provider}
With the implemented MapFragment it is possible to display an overlay with your own custom tile set. This is done by providing the MapFragment with a\linebreak UrlTileProvider\citep{tilecoordinates}. This class has a method called \lstinline|getTileUrl()| that specifies how to get each tile. The method will be automatically called by the MapFragment every time the user moves into a region where tiles still has not been loaded. The parameters for \lstinline|getTileUrl()| is the tile's x, y coordinate, as seen on \autoref{fig:tilecoordinates}, and the current zoom level.

Our tile set is stored on the URL "figz.dk/dl/FloorPlan/". A tile is uniquely identified with the URL "figz.dk/dl/FloorPlan/zoom-level/x/y.png". We have created tiles from zoom level 2 to 6, meaning that we have $4^2+8^2+16^2+32^2+64^2 = 5456$ tiles. We could easily have created more zoom-levels and thereby tiles, but our example floor plan does not require much detail, and it would be confusing if the user could zoom closer. When our custom tile set is created and shown, we can simply hide the standard Google Maps standard Earth tile set. This is done to avoid loading unnecessary data.

\subsection*{Loading the Walk Path}
With the MapFragment implemented and the tiles loaded, we can draw the walk path of the exhibition. The walk path has previously been made and uploaded to the database by our website, which will be explained in\secref{sec:websiteimplementation}. When the walk path has been created, we load the nodes and edges from the database. With the nodes and edges we create a graph object, and from this undirected graph we create a polyline.

The polyline has a special structure, each of its elements is a latitude and longitude coordinate and between each coordinate pair, a line segment is drawn. The polyline's coordinates are defined as if you were to draw a walk path on a map, but you could never let go or lift the pencil from the paper, as seen on\autoref{fig:polylineexample}. Meaning that in order to create the polyline we might need to define an edge more than once. \autoref{lst:makePolyLine} shows the method that we use to make our walk path, and the shortest path polyline, from the undirected graph.
\begin{lstlisting}[language=java, label=lst:makePolyLine, caption=makePolyLine]
public void makePolyLine() {
    this.polylinePath = new ArrayList<Node>();
    for(Edge edge : this.getEdges()){
        int indexNodeA = this.polylinePath.indexOf(edge.getNodeA());
        int indexNodeB = this.polylinePath.indexOf(edge.getNodeB());
        
        if(indexNodeB != -1){
           this.polylinePath.add(indexNodeB + 1, edge.getNodeA());
           this.polylinePath.add(this.polylinePath.indexOf(edge.getNodeA())+1, edge.getNodeB());
        }
        else if(indexNodeA != -1 ){
           this.polylinePath.add(indexNodeA + 1, edge.getNodeB());
           this.polylinePath.add(this.polylinePath.indexOf(edge.getNodeB())+1, edge.getNodeA());
        }
        else{
           this.polylinePath.add(edge.getNodeA());
           this.polylinePath.add(edge.getNodeB());
        }
    }

    ArrayList<LatLng> polyLine = new ArrayList<LatLng>();
    for(Node n : this.polylinePath){
        polyLine.add(n.getPosition());
    }
}
\end{lstlisting}
\begin{description}
\item[Line 2] Start by creating a local array called  \lstinline|polyLinePath|, which consists of nodes.
\item[Lines 3-5] For each edge in our undirected graph, get the index of Node A and B in the newly created array \lstinline|polyLinePath|.
\item[Lines 7-10] If Node B already exists in the \lstinline|polyLinePath| insert the two nodes in the following order (...,NodeB, NodeA, NodeB, ...)
\item[Lines 11-14] If Node A already exists in the \lstinline|polyLinePath| insert the two nodes in the following order (...,NodeA, NodeB, NodeA, ...)
\item[Lines 15-18] Else just add the two nodes to the array, this will only be done once.
\item[Lines 21-24] Now that the loop is done, simply add every node's latitude and longitude to an array called \lstinline|polyLinePath|, which is the result of the function. 
\end{description}

\subsection*{Route and Limitations}
The graph can now be presented on the map, with the polyline walk path. We want to find the shortest path between two nodes, for this we use the Dijkstra's shortest path algorithm. We will not go into detail how this is implemented since it is fairly simple. With our graph object we can calculate the shortest path. The weights of the edges is simply the distance between two nodes, and from this we can find the shortest route between the two nodes, source and target.

A user can set his target/destination by pressing on a booth's marker and press the button "Navigate to" in the info window, a red polyline will appear on the floor plan showing the shortest route, but only if the user has a known position.

If an \ac{nfc} tag is scanned and the tag has a node ID stored on it, the application will automatically show the floor plan, zoom onto the location of the node displaying a red dot, and updating the user's position/source. The shortest path(red polyline) between the target and the user's new position is calculated from the undirected graph. The result is made into a polyline with the method  \autoref{lst:makePolyLine} and drawn onto the floor plan, like the walk path. This is done every time the user scans an \ac{nfc} and changes his position.

If the scanned node is connected to a booth, meaning the node is a booth's entry point, then the red dot's position will be portrayed on the booth instead on the walk path.

At the moment the floor plan implementation can only show a route between two nodes, It is not possible to show a route between multiple destinations or nodes. Also it is not possible to unsubscribe from a booth, directly from the floor plan.







	

\section*{Block 2: Data I: XML etc.}

We found an XML document containing a small set of computers for sale on eBay, which we will display a subset of. We will be using the following:
\begin{itemize}
\item An XML file containing data on computers for sale.
\item An XSL file with our XSL transformations (XSLT).
\item A HTML file which contains only a little javascript to load the other files and display the result.
\end{itemize}

\begin{lstlisting}[language=xslt,label=lst:xslt] 
<?xml version="1.0" encoding="ISO-8859-1"?>
<xsl:stylesheet version="1.0" xmlns:xsl="http://www.w3.org/1999/XSL/Transform">

<xsl:template match="/">
  <h2>Computers for sale on eBay</h2>
    <table border="1">
      <tr bgcolor="#9acd32">
        <th>Current bid</th>
        <th>Memory</th>
        <th>Hard drive</th>
        <th>CPU</th>
      </tr>
      <xsl:for-each select="root/listing">
      <tr>
        <td><xsl:value-of select="auction_info/current_bid"/></td>
        <td><xsl:value-of select="item_info/memory"/></td>
        <td><xsl:value-of select="item_info/hard_drive"/></td>
        <td><xsl:value-of select="item_info/cpu"/></td>
      </tr>
      </xsl:for-each>
    </table>
</xsl:template>
</xsl:stylesheet>
\end{lstlisting}

This is the XSL file with our transformation. The following box is copied from w3schools.com \citep{w3xslt}.

\begin{framed}
Since an XSL style sheet is an XML document, it always begins with the XML declaration: \lstinline$<?xml version="1.0" encoding="ISO-8859-1"?>$.

The next element, \lstinline$<xsl:stylesheet>$, defines that this document is an XSLT style sheet document (along with the version number and XSLT namespace attributes).

The \lstinline$<xsl:template>$ element defines a template. The \lstinline$match="/"$ attribute associates the template with the root of the XML source document.

The content inside the \lstinline$<xsl:template>$ element defines some HTML to write to the output.
\end{framed}

\subsection{XML vs XSLT}

XQuery and XSLT are two languages used for quering XML. We have chosen to experience a bit with both  to find out how they worked.

We spent a lot of time trying to make XQuery work with PHP Zorba. Zorba is a sort of virtual machine for query processing, however we could not make it work with the newest version of PHP for some reason, so we ended up using an Eclipse plugin called  "Sausalito Tools" for the Xquery, allowing us to read an XML document and extract information but we did not connect it to our database. 

It allowed us to get a general understanding of XQuery and XPath and how to extract information from an XML file using these queries. 

XSLT is primarily conceived as a stylesheet language used to render XML on screen where as XQuery is conceived as a database query language and in our case our main focus is to query an XML file in our database and not styling our website. 

XSLT is stronger when it comes to making small changes to a document, because it can make use of a coding pattern that involves a template that copies all nodes unchanged, modified by specific templates that modify selected nodes.

XQuery does not support dynamic binding or polymorphism, but this ability is more noticeable when writing large applications, which we do not expect to be doing. 
